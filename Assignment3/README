As you know at this point, Dynamic Programming is a powerful technique
that explores all possible cases to obtain a solution, yet achieves an exponential improvement in running time when compared with a simpler brute-force
approach. A well-known example of Dynamic Programming usage is Text
Justification, where we are given an array of words and a page width and we
have to decide how to split the text so that it looks “nice” after justifying
against margins. The purpose of this homework is to compare experimentally
the result obtained justifying text with a greedy algorithm (as used by MS
Word) against doing the same using LATEX rules and Dynamic Programming.
Specifically, your assignment is the following.
1. Implement a “badness” method that, given a width ω as a
number of characters, an array W[0 . . . n−1] of strings, and two indices
i and j such that 0 ≤ i ≤ n − 1 and 1 ≤ j ≤ n, computes the following
function used by LATEX.
badness(W, i, j, ω) = 
(ω − `(W, i, j))3
if ω − `(W, i, j) ≥ 0,
∞ otherwise.
Where `(W, i, j) is the total length in characters of the words from
index i to j − 1 in the array W, taking into account that one space
must be left in between each pair of consecutive words.
2. Implement a “split” method that, given as parameters the
width ω and the array W, returns a list L of the indices of the array
where each line should start to minimize the aggregated badness (i.e.
the sum of the badness of all lines in such split). The Dynamic Programming pseudocode to compute the minimum aggregated badness
seen in class follows in Algorithms 1 and 2. You have to expand it to
return the list of indices of the corresponding split.
3. Implement a “justify” method that, given as parameters the
width ω, the array of words W, and the list of breakpoints L, creates
a text file, call it for instance just.txt, justified accordingly. That is,
for each line, your code should spread the words evenly in the width
of ω characters. Hint: a line starting at index i and ending at index
j − 1 has j − i words. So, the ω − `(W, i, j) space characters have to be
distributed roughly evenly among the j − i − 1 separations of words.
4
Algorithm 1: Minimum Badness
input : an array W[0 . . . n − 1] of n strings and an integer ω.
output: minimum aggregated badness.
1 memo[0 . . . n] ← new array of integers
2 for i = 0 to n do memo[i] ← −1
3 return Memoized Minimum Badness(W, 0, memo, ω)
Algorithm 2: Memoized Minimum Badness
input : an array W[0 . . . n − 1] of n strings, an integer i in the range
[0, n], an array memo[0 . . . n] of integers, and an integer ω.
output: minimum aggregated badness of the suffix [i,n-1] of W.
1 if memo[i] ≥ 0 then return memo[i]
2 if i = n then memo[i] ← 0
3 else
4 min ← ∞
5 for j = i + 1 to n do
6 temp ← badness(W, i, j, ω)
7 temp ← temp + Memoized Minimum Badness(W, j, memo, ω)
8 if temp < min then min ← temp
9 memo[i] ← min
10 return memo[i]
4.  Implement a main method that prompts the user to enter a
number of words n and a page width ω as a number of characters. Then,
create the array W[0 . . . n−1] of strings and fill it with random strings.
The length of each string should be chosen at random in the range
[1, 15]. Notice that, to the extent to evaluate the result of justification,
the actual characters used are irrelevant. For instance, you could choose
all the characters to be the same, as in “aaaaaaaaaaa”. (If you prefer
to use real text, read the words from an input file or the web.) Then,
your main method should call the method “split” to obtain the list of
breakpoints L, and subsequently call the method “justify” passing W,
ω, and L as parameters. Finally, output the array W to a second text
file in a single line, call it for instance unjust.txt.
5
5. Evaluation: Compare the result of just.txt with unjust.txt
opening the latter in MS Word and justifying the text. How do they
look? Can you evaluate if MS Word is using a greedy approach? Play
with the maximum word length of 15 as needed.
